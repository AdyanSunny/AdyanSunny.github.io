<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java项目自动打包部署]]></title>
    <url>%2F2020%2F11%2F18%2Fjava%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[记录Java项目使用shell脚本实现自动化部署服务器 直接上脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/bin/sh# 脚本目录DIR=$(cd `dirname $0`; pwd) # git 仓库路径GIT_DIR="$&#123;DIR&#125;/git/仓库" echo "脚本路径===========$&#123;DIR&#125;"echo "git仓库路径 ===============$&#123;GIT_DIR&#125;"# 检查gitecho " - git update $&#123;GIT_DIR&#125;";if [ -d "$&#123;GIT_DIR&#125;" ]; then cd "$&#123;GIT_DIR&#125;" git checkout test git pullelse echo " - module dir is empty!"; exit 1fiecho "==============开始打war包==============="# gradle 打包路径SERVER_WAR="$&#123;GIT_DIR&#125;/service"cd "$&#123;SERVER_WAR&#125;"gradle clean buildBUILD_PATH="$&#123;SERVER_WAR&#125;/project.war"if [ ! -e $&#123;BUILD_PATH&#125; ]; then echo " - the build $&#123;BUILD_PATH&#125; not find ! "; exit 1fi# WAR包路径PATH_TO_WAR="$&#123;DIR&#125;/warfile"PATH_TO_WAR_FILE="$&#123;PATH_TO_WAR&#125;/project.war"echo "=================开始复制war包到$&#123;PATH_TO_WAR&#125;=========="if [ ! -d $&#123;PATH_TO_WAR&#125; ]; then mkdir -p $&#123;PATH_TO_WAR&#125;;fiif [ -f $&#123;PATH_TO_WAR_FILE&#125; ]; then echo "===========删除原war包==========" rm -rf $&#123;PATH_TO_WAR_FILE&#125;;fi#备份的上一个文件PATH_TO_WAR_FILE_BACK="$&#123;PATH_TO_WAR&#125;/project_back.war"if [ -f $&#123;PATH_TO_WAR_FILE_BACK&#125; ]; then echo "===========删除上一个备份的包==========" rm -rf $&#123;PATH_TO_WAR_FILE_BACK&#125;;fiif [ -f $&#123;PATH_TO_WAR_FILE&#125; ]; then echo "===========备份war包==========" mv $&#123;PATH_TO_WAR_FILE&#125; "$&#123;PATH_TO_WAR&#125;/project_back.war";ficp $&#123;BUILD_PATH&#125; $&#123;PATH_TO_WAR_FILE&#125;echo "=============杀死tomcat进程=========="KILL_NAME="tomcat-15"ID=`ps -ef | grep "$KILL_NAME" | grep -v "$0" | grep -v "grep" | awk '&#123;print $2&#125;'`echo "=========进程$&#123;ID&#125;========="for id in $IDdokill -9 $idecho "============killed $id========"doneecho "===========启动tomcat=========="TOMCAT1="$&#123;DIR&#125;/tomcat-15100/bin"cd $&#123;TOMCAT1&#125;./startup.shecho "==========$&#123;TOMCAT1&#125;启动中==========="TOMCAT2="$&#123;DIR&#125;/tomcat-15200/bin"cd $&#123;TOMCAT2&#125;./startup.shecho "==========$&#123;TOMCAT2&#125;启动中==========="TOMCAT3="$&#123;DIR&#125;/tomcat-15300/bin"cd $&#123;TOMCAT3&#125;./startup.shecho "==========$&#123;TOMCAT3&#125;启动中==========="echo "==========脚本执行完毕============"#tomcat 相关配置&lt;Connector port="15100" redirectPort="15102" connectionTimeout="20000" protocol="HTTP/1.1"/&gt;&lt;Host name="localhost" autoDeploy="true" unpackWARs="true" appBase="webapps"&gt; &lt;Context reloadable="true" docBase="/opt/warfile/padproject.war" path=""/&gt;&lt;/Host&gt; 服务器配置目录 脚本中使用了三个点的Tomcat。所以只要配置好三个点的tomcat就行了。 本次记录与实际工作中的一些经验。当然，本脚本并非原创。只是为了方便后面使用。 有幸能看到这个脚本的大佬，可以提一点意见，将其优化一下。使其使用更为方便。]]></content>
      <categories>
        <category>Java</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java上传视频并且截取当前视频第一帧]]></title>
    <url>%2F2020%2F09%2F28%2Fjava%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%B8%94%E6%88%AA%E5%8F%96%E5%BD%93%E5%89%8D%E8%A7%86%E9%A2%91%E7%AC%AC%E4%B8%80%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[java实现上传视频文件并且截取视频第一帧，保存到数据库。 这是我通过查找其他相关资料结合自己的想法写的一个有关于移动端拍摄上传视频，并且截取视频第一帧的方法，个人觉得比调用ffffmpeg要简单方便很多。 注释都写的很清楚的，就看你们的造化了。 maven依赖第一个好像是没有用到的。至于是真是假，自己去验证。 maven相关： 12345678910111213141516171819202122&lt;!--截取视频第一帧--&gt;&lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacpp-presets&lt;/artifactId&gt; &lt;version&gt;1.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.openpnp&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;3.4.2-1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacpp&lt;/artifactId&gt; &lt;version&gt;1.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv-platform&lt;/artifactId&gt; &lt;version&gt;1.4.3&lt;/version&gt;&lt;/dependency&gt; 控制层：Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*** * 获取指定视频的帧并保存为图片至指定目录 * @param request * @param files * @return * @throws IOException */@RequestMapping(value = "/userUpload",method = RequestMethod.POST)@ResponseBodypublic ResultDate userUpload(@RequestParam(value = "files", required = false) MultipartFile files, HttpServletRequest request, @RequestParam(value = "title") String title) throws Exception &#123; try &#123; KidsUserVideo userVideo =new KidsUserVideo(); //填补内容 userVideo.setUserVideoTitle(title); userVideo.setUserVideoUptime(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(System.currentTimeMillis())));//设置上传时间 //获取文件名称 String fileName = files.getOriginalFilename(); // 自定义方式产生文件名 String serialName = String.valueOf(System.currentTimeMillis()); // 截取文件格式 String fileType = fileName.substring(fileName.lastIndexOf(".")); // 上传视频存放路径 String filePath = request.getSession().getServletContext().getRealPath("/temp"); String realPath = request.getSession().getServletContext().getRealPath(File.separator); System.out.println(realPath); //开始上传 File f = new File(filePath); if (!f.exists()) &#123;//如果没有这个目录， f.mkdirs();//就创建一个新的目录 &#125; if (files.getSize() &gt; 100 * 1024 * 1024) &#123;//判断上传的视频文件是否过大 return ResultDate.build(403,"上传失败！您上传的文件太大,系统允许最大文件500M"); &#125; //上传视频 //上传视频存放的地址 String videoPath = filePath + "/videos/" + serialName + fileType; //截取图片存放的地址 String imgPath = filePath + "/images/"; files.transferTo(new File(videoPath)); // 转存文件 File img = new File(imgPath); if (!img.exists()) &#123;//如果没有这个目录， img.mkdirs();//就创建一个新的目录 &#125; //调用截取视频第一帧的方法 boolean falg = mediaService.executeCodecs(videoPath,imgPath,serialName); //System.out.println("返回结果："+falg); //获取ip地址 String IP = Inet4Address.getLocalHost().toString(); int index = IP.indexOf('/'); String ip = IP.substring(index+1, IP.length()); String localhostIp = "http://" + ip + ":8080/"; userVideo.setUserVideoPath(localhostIp+"temp/videos/"+serialName + fileType); userVideo.setUserVideoPicture(localhostIp+"temp/images/" + serialName + ".jpg"); if(falg==true)&#123;//判断返回结果 //等于true的话，就上传截图成功 return ResultDate.ok(mediaService.saveMedia(userVideo)); &#125; return ResultDate.build(403,"上传截图异常！请重试。"); &#125; catch (Exception e) &#123; logger.error("上传视频异常：", e); &#125; //其他错误 return ResultDate.build(403,"上传错误！");&#125; 业务层：ServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** * 获取指定视频的帧并保存为图片至指定目录 * @param filePath 视频存放的地址 * @param targerFilePath 截图存放的地址 * @param targetFileName 截图保存的文件名称 * @return * @throws Exception */@Overridepublic boolean executeCodecs(String filePath, String targerFilePath, String targetFileName) throws Exception &#123; try&#123; FFmpegFrameGrabber ff = FFmpegFrameGrabber.createDefault(filePath); ff.start(); String rotate =ff.getVideoMetadata("rotate"); Frame f; int i = 0; while (i &lt;1) &#123; f =ff.grabImage(); IplImage src = null; if(null !=rotate &amp;&amp;rotate.length() &gt; 1) &#123; OpenCVFrameConverter.ToIplImage converter =new OpenCVFrameConverter.ToIplImage(); src =converter.convert(f); f =converter.convert(rotate(src, Integer.valueOf(rotate))); &#125; doExecuteFrame(f,targerFilePath,targetFileName); i++; &#125; ff.stop(); return true; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return false;&#125;/* * 旋转角度的 */public static IplImage rotate(IplImage src, int angle) &#123; IplImage img = IplImage.create(src.height(), src.width(), src.depth(), src.nChannels()); opencv_core.cvTranspose(src, img); opencv_core.cvFlip(img, img, angle); return img;&#125;public static void doExecuteFrame(Frame f, String targerFilePath, String targetFileName) &#123; if (null ==f ||null ==f.image) &#123; return; &#125; Java2DFrameConverter converter =new Java2DFrameConverter(); String imageMat ="jpg"; String FileName =targerFilePath + File.separator +targetFileName +"." +imageMat; BufferedImage bi =converter.getBufferedImage(f); System.out.println("width:" + bi.getWidth());//打印宽、高 System.out.println("height:" + bi.getHeight()); File output =new File(FileName); try &#123; ImageIO.write(bi,imageMat,output); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 代码有部分比较冗余，可以根据自己需求删减。 此方法已验证。可以完美的截取到想要的视频帧。 只不过我这里做的只是将其照片存放在服务器本地，如果有单独的图片服务器，可以将存放地址换一下。 另外在CSDN上都有发布：java上传视频并且截取当前视频第一帧 欢迎评论，指出不足~~~~~~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2020%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
